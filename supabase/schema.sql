-- Enable Row Level Security
-- alter table auth.users enable row level security; -- SKIPPED: Managed by Supabase by default

-- 1. Profiles Table
-- Stores user metadata and encrypted tokens
create table public.profiles (
  id uuid references auth.users not null primary key,
  email text,
  google_refresh_token text, -- Encrypted
  spreadsheet_id text,
  updated_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.profiles enable row level security;

-- Policies for Profiles
-- Users can see their own profile
create policy "Users can view own profile" on public.profiles
  for select using (auth.uid() = id);

-- Users can update their own profile
create policy "Users can update own profile" on public.profiles
  for update using (auth.uid() = id);

-- 2. Cached Locations
-- Stores the sync'd data from Google Sheets
create table public.cached_locations (
  id bigint generated by default as identity primary key,
  owner_id uuid references public.profiles(id) not null,
  sheet_id text not null,
  data jsonb not null default '[]'::jsonb,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Ensure one cache entry per user (owner)
  constraint unique_owner_cache unique (owner_id)
);

alter table public.cached_locations enable row level security;

-- Policies for Cached Locations
-- Owner can see their own cache
create policy "Users can view own cache" on public.cached_locations
  for select using (auth.uid() = owner_id);

-- Shared Access Policy (Placeholder for now)
-- We will implement strict sharing via the backend logic mostly, 
-- but if we want RLS to enforce it:
-- create policy "Viewers can view shared cache" on public.cached_locations
--   for select using (
--     exists (
--       select 1 from public.shared_access
--       where owner_id = cached_locations.owner_id
--       and viewer_email = auth.jwt() ->> 'email'
--     )
--   );

-- 3. Shared Access
-- Manages who can view whose list
create table public.shared_access (
  id bigint generated by default as identity primary key,
  owner_id uuid references public.profiles(id) not null,
  viewer_email text not null,
  permission_level text default 'view', -- 'view' or 'edit'
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.shared_access enable row level security;

-- Policies for Shared Access
-- Owner can manage their shares
create policy "Owner can manage shares" on public.shared_access
  for all using (auth.uid() = owner_id);

-- Viewers can see what has been shared with them
create policy "Viewers can see their access" on public.shared_access
  for select using (viewer_email = (select email from public.profiles where id = auth.uid()));

-- Trigger to create profile on Signup
create or replace function public.handle_new_user() 
returns trigger as $$
begin
  insert into public.profiles (id, email)
  values (new.id, new.email);
  return new;
end;
$$ language plpgsql security definer;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
